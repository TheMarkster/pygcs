from __future__ import annotations

from .event import Event
from typing import List

class EventHandler:
    def __init__(self, name=None):
        self._name = name or f"EventHandler-{id(self)}"
        self._forwarding = [] # Send a copy of all signals here
        self._event_history = []  # For debugging/replay
        self._forwarding = []
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def event_history(self) -> List[Event]:
        return self._event_history

    @property
    def forwarding(self) -> List[EventHandler]:
        return self._forwarding
    
    def forward_to(self, gateway: EventHandler):
        """Add a gateway function to forward all events to"""
        self.forwarding.append(gateway)
    
    def remove_forwarding(self, gateway: EventHandler):
        """Remove a gateway function from forwarding"""
        if gateway in self.forwarding:
            self.forwarding.remove(gateway)

    def receive(self, event: Event):
        """Entry point for all events received and generated by this handler"""
        # For debugging/replay
        self.event_history.append(event)

        # Record this node in the path
        event.get_local_path().append(self.name)

        # Do stuff and then forward
        event = self.process(event)
        self.forward(event)
    
    def process(self, event: Event) -> Event:
        """Process the received event"""
        raise NotImplementedError("Subclasses must implement process()")

    def forward(self, event: Event):
        local_path = event.get_local_path()

        if not event._metadata.get('_forward', True):
            # Don't forward to gateways if this is a local-only event
            return

        for gateway in self.forwarding:
            if gateway.name in local_path:
                # Don't forward to previous nodes in the path (avoid loops)
                continue

            try:
                gateway.receive(event)
            except Exception as e:
                # Use registry to avoid circular dependency
                # broadcast('forwarding_error', event.signal, gateway, e)
                # print(f"‚ùå Error forwarding event '{event.signal}' to {gateway.name}: {e}")
                raise RuntimeError(
                    f"Error forwarding event '{event.signal}' to {gateway.name}: {e}"
                ) from e

    def get_event_history(self, signal=None, limit=None):
        """Get event history, optionally filtered by signal"""
        history = self.event_history
        if signal:
            history = [event for event in history if event.signal == signal]
        if limit:
            history = history[-limit:]
        return history
    
    def clear_history(self):
        """Clear the event history"""
        self.event_history.clear()
