from __future__ import annotations
from typing import Union, Dict, Tuple, List, Callable
from dataclasses import dataclass, field
import json
import threading

if 'BROADCAST_MODULE' in globals():
    raise Exception("broadcast.py loaded multiple times!")
else:
    BROADCAST_MODULE = True

@dataclass
class Event:
    signal: str
    args: tuple
    kwargs: dict
    _metadata: dict

    def to_dict(self) -> dict:
        return {
            'signal': self.signal,
            'args': self.args,
            'kwargs': self.kwargs,
            '_metadata': self._metadata
        }

    @staticmethod
    def from_dict(data: dict) -> Event:
        return Event(
            signal=data.get('signal', ''),
            args=tuple(data.get('args', ())),
            kwargs=data.get('kwargs', {}),
            _metadata=data.get('_metadata', {})
        )

    def serialize(self) -> str:
        return json.dumps(self.to_dict())

    @staticmethod
    def deserialize(data: str) -> Event:
        data = json.loads(data)
        return Event.from_dict(data)
    
    def get_path_data(self):
        devices = self._metadata.setdefault('device', [])
        if len(devices) == 0:
            devices.append('localhost')
        path = self._metadata.setdefault('path', [])
        if len(path) == 0:
            path.append([])

        return devices, path

    def get_local_path(self):
        devices, path = self.get_path_data()
        return path[-1]

    def push_path(self, host: str):
        # Local host data pushed back as we enter new network
        devices, path = self.get_path_data()

        devices.insert(-1, host)  # Insert before 'localhost'
        path.insert(-1, path[-1].copy())  # Duplicate current local path segment
        path[-1].clear()

def broadcast(signal, *args, _metadata=None, **kwargs):
    ...

class EventHandler:
    def __init__(self, name=None):
        self._name = name or f"EventHandler-{id(self)}"
        self._forwarding = [] # Send a copy of all signals here
        self._event_history = []  # For debugging/replay
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def event_history(self) -> List[Event]:
        return self._event_history

    @property
    def forwarding(self) -> List[EventHandler]:
        return self._forwarding
    
    def forward_to(self, gateway_func: EventHandler):
        """Add a gateway function to forward all events to"""
        self.forwarding.append(gateway_func)

    def receive(self, event: Event):
        """Entry point for all events received and generated by this handler"""
        # For debugging/replay
        self.event_history.append(event)

        # Record this node in the path
        event.get_local_path().append(self.name)

        # Do stuff and then forward
        event = self.process(event)
        self.forward(event)
    
    def process(self, event: Event) -> Event:
        """Process the received event"""
        raise NotImplementedError("Subclasses must implement process()")

    def forward(self, event: Event):
        local_path = event.get_local_path()

        if event._metadata.get('_local_only', False):
            # Don't forward to gateways if this is a local-only event
            return

        for gateway in self.forwarding:
            if gateway.name in local_path:
                # Don't forward to previous nodes in the path (avoid loops)
                continue

            try:
                gateway.receive(event)
            except Exception as e:
                broadcast('forwarding_error', event.signal, gateway, e)

    def get_event_history(self, signal=None, limit=None):
        """Get event history, optionally filtered by signal"""
        history = self.event_history
        if signal:
            history = [event for event in history if event.signal == signal]
        if limit:
            history = history[-limit:]
        return history
    
    def clear_history(self):
        """Clear the event history"""
        self.event_history.clear()


class EventHost(EventHandler):
    def __init__(self, name=None):
        if name is None:
            name = f"EventHost-{id(self)}"

        super().__init__(name)
        self._instances = {} # class.name -> List[instance]
        self._consumers = {} # signal -> List[Tuple[func, class]]
    
    @property
    def instances(self) -> Dict[str, list]:
        return self._instances

    @instances.setter
    def instances(self, value: Dict[str, list]):
        self._instances = value

    @property
    def consumers(self) -> Dict[str, List[Tuple[callable, Union[str, None]]]]:
        return self._consumers

    def process(self, event) -> Event:
        target_consumers = self.consumers.get(event.signal, [])
        
        for func, cls_name in target_consumers:
            if cls_name is None:
                # Standalone function - call directly
                try:
                    func(*event.args, **event.kwargs)
                except Exception as e:
                    # Error handling for robust addon system
                    self.broadcast('broadcast_error', event.signal, 'standalone_function', e)
            else:
                # Class method - call on all instances of the class
                for instance in self.instances.get(cls_name, []):
                    try:
                        func(instance, *event.args, **event.kwargs)
                    except Exception as e:
                        # Error handling for robust addon system
                        self.broadcast('broadcast_error', event.signal, cls_name, e)

        return event

    def broadcast(self, signal, *args, _metadata=None, **kwargs):
        event = Event(signal, args, kwargs, _metadata or {})
        self.receive(event)

    def consumer(self, signal: str):
        """Decorator to register a method as a consumer for a signal"""
        def decorator(func):
            # Check if this is a class method or a standalone function
            qualname_parts = func.__qualname__.split(".")
            is_class_method = len(qualname_parts) > 1 and '<locals>' not in qualname_parts
            
            if is_class_method:
                cls_name = qualname_parts[0]
                
                # For class methods, we'll defer the inheritance check until the method is actually called
                # or we can check it during emit() when we have access to the instance
                
                # Store the original function and mark it as needing inheritance check
                func._broadcast_needs_inheritance_check = True
                func._broadcast_class_name = cls_name
                
                # For class methods, store the class name for instance lookup
                self.consumers.setdefault(signal, []).append((func, cls_name))
            else:
                # For standalone functions, store None as the class name
                self.consumers.setdefault(signal, []).append((func, None))
                
            return func
        return decorator

    def register_instance(self, instance, namespace=None):
        """Register an instance to receive broadcast signals"""
        cls_name = instance.__class__.__name__
        self.instances.setdefault(cls_name, []).append(instance)
        # if namespace:
        #     self.namespaces[cls_name] = namespace
        
        # Emit registration event
        self.broadcast('instance_registered', instance)
    
    def unregister_instance(self, instance):
        """Unregister an instance from receiving broadcasts"""
        cls_name = instance.__class__.__name__
        instances_list = self.instances.get(cls_name, [])
        if instance in instances_list:
            instances_list.remove(instance)
            # Clean up empty lists
            if not instances_list:
                del self.instances[cls_name]
        
        # Emit unregistration event
        self.broadcast('instance_unregistered', instance)
    
    def get_registered_consumers(self, signal=None):
        """Get list of registered consumers, optionally for a specific signal"""
        if signal:
            return self.consumers.get(signal, [])
        return self.consumers.copy()
    
    def get_registered_instances(self, cls_name=None):
        """Get registered instances, optionally for a specific class"""
        if cls_name:
            return self.instances.get(cls_name, [])
        return self.instances.copy()

class Broadcastable:
    """Base class for objects that can receive broadcast events"""
    def __init__(self, namespace=None):
        self._broadcast_namespace = namespace
        events.register_instance(self, namespace)
    
    def __del__(self):
        events.unregister_instance(self)

# Singleton instance
events = EventHost()

def broadcast(signal, *args, _metadata=None, **kwargs):
    """Convenience function to broadcast an event"""
    events.broadcast(signal, *args, _metadata=_metadata, **kwargs)

def local_broadcast(signal, *args, _metadata=None, **kwargs):
    """Broadcast an event that should not be forwarded to gateways"""
    _metadata = _metadata or {}
    _metadata['_local_only'] = True
    events.broadcast(signal, *args, _metadata=_metadata, **kwargs)